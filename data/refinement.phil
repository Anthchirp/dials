refinement
  .help = "Parameters to configure the refinement"
{

  parameterisation
    .help = "Parameters to control the parameterisation of experimental models"
  {
    beam
      .help = "beam parameters"
    {
      fix_beam = False
        .help = "Fix all beam orientation parameters"
        .type = bool
      fix_in_spindle_plane = True
        .help = "If a goniometer is present and this option is True, the beam"
                "orientation is restricted to a direction in the initial"
                "spindle-beam plane"
        .type = bool
    }

    crystal
      .help = "crystal parameters"
    {
      fix_cell = False
        .help = "Fix all cell parameters"
        .type = bool
      fix_orientation = False
        .help = "Fix all orientation parameters"
        .type = bool
      scan_varying = False
        .help = "Parameterise the crystal to vary during the scan"
        .type = bool
      num_intervals = 5
        .help = "Number of intervals between checkpoints if scan_varying"
                "refinement is requested"
      .type = int(value_min=1)
     }

    detector
      .help = "detector parameters"
    {
      panels = *automatic single multiple
        .help = "Select appropriate detector parameterisation. Currently the"
                "choice is between a single or multiple panel detector, in"
                "either case treated as a rigid body. The default choice"
                "automatically chooses multiple if the number of panels > 1"
        .type = choice
      fix_orientation = False
        .help = "Fix orientation parameters"
        .type = bool
      fix_position = False
        .help = "Fix positional parameters"
        .type = bool
    }
  }

  refinery
    .help = "Parameters to configure the refinery"
  {
    engine = SimpleLBFGS LBFGScurvs *GaussNewtonIterations
      .help = "The minimisation engine to use"
      .type = choice

    track_step = False
      .help = "Record parameter shifts history in the refinement journal, if"
              "the engine supports it."
      .type = bool

    track_gradient = False
      .help = "Record parameter gradients history in the refinement journal, if"
              "the engine supports it."
      .type = bool

    log = None
      .help = "Filename for an optional log that a minimisation engine may use"
              "to write additional information"
      .type = path

    max_iterations = None
      .help = "Maximum number of iterations in refinement before termination."
              "None implies the engine supplies its own default."
      .type = int(value_min=1)
  }

  target
    .help = "Parameters to configure the target function"
  {
    implementation = *basic XY
      .help = "The target object type to use. Basic expresses residuals"
              "in X, Y, Phi space. XY does not use Phi."
      .type = choice

    rmsd_cutoff = *fraction_of_bin_size absolute
      .help = "Method to choose rmsd cutoffs. This is currently either as a"
              "fraction of the discrete units of the spot positional data, i.e."
              "(pixel width, pixel height, image thickness in phi), or a tuple"
              "of absolute values to use as the cutoffs"
      .type = choice

    bin_size_fraction = 0.33333
      .help = "Cut off in the natural discrete units of positional data, viz.,"
              "(pixel width, pixel height, image thickness in phi) to use to"
              "determine when the RMSD target is achieved. Only used if"
              "rmsd_cutoff = fraction_of_bin_size."
      .type = float(value_min=0.)

    absolute_cutoffs = None
      .help = "Absolute Values for the RMSD target achieved cutoffs in X, Y and"
              "Phi. The units are (mm, mm, rad)."
      .type = floats(size=3, value_min=0.)
  }

  reflections
    .help = "Parameters used by the reflection manager"
  {
    implementation = *rotation stills
      .help = "The reflection manager type to use. rotation is for a"
              "rotation scan and removes reflections too close to the"
              "spindle-beam plance. stills does not do this"
      .type = choice

    reflections_per_degree = 50
      .help = "The number of centroids per degree of the sweep to use in"
              "refinement."
      .type = float(value_min=0.)

    maximum_number_of_reflections = None
      .help = "The maximum number of reflections to use in refinement."
              "Overrides reflections_per_degree if that produces a"
              "larger sample size."
      .type = int(value_min=1)

    use_all_reflections = False
      .help = "Override reflections_per_degree and use all available centroids"
              "in refinement."
      .type = bool

    random_seed = 42
      .help = "Random seed to use when sampling to create a working set of"
              "reflections. May be int or None."
      .type = int

    minimum_number_of_reflections = 20
      .help = "The minimum number of input observations to allow a reflection"
              "manager to be constructed for."
      .type = int(value_min=1)

    inclusion_cutoff = 0.1
      .help = "The inclusion criterion currently uses the volume of the"
              "parallelepiped formed by the spindle axis, the incident"
              "beam and the scattered beam. If this is lower than some"
              "value then the reflection is excluded from refinement."
              "In detector space, these are the reflections located close"
              "to the rotation axis."
      .type = float(value_min = 0)
  }
}
