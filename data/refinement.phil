refinement
  .help = "Parameters to configure the refinement"
{

  parameterisation
    .help = "Parameters to control the parameterisation of experimental models"
  {
    beam
      .help = "beam parameters"
    {
      fix_beam = False
        .help = "Fix all beam orientation parameters"
        .type = bool
      fix_in_spindle_plane = True
        .help = "If a goniometer is present and this option is True, the beam"
                "orientation is restricted to a direction in the initial"
                "spindle-beam plane"
        .type = bool
    }

    crystal
      .help = "crystal parameters"
    {
      fix_cell = False
        .help = "Fix all cell parameters"
        .type = bool
      fix_orientation = False
        .help = "Fix all orientation parameters"
        .type = bool
      scan_varying = False
        .help = "Parameterise the crystal to vary during the scan"
        .type = bool
      num_intervals = 5
        .help = "Number of intervals between checkpoints if scan_varying"
                "refinement is requested"
      .type = int(value_min=1)
     }

    detector
      .help = "detector parameters"
    {
      panels = *single multiple
        .help = "Parameterise a single or multiple panel detector"
        .type = choice
      fix_detector = False
        .help = "Fix all detector parameters"
        .type = bool
    }
  }

  refinery
    .help = "Parameters to configure the refinery"
  {
    engine = SimpleLBFGS LBFGScurvs *GaussNewtonIterations
      .help = "The minimisation engine to use"
      .type = choice

    track_step = False
      .help = "Record parameter shifts history in the refinement journal, if"
              "the engine supports it."
      .type = bool

    track_gradient = False
      .help = "Record parameter gradients history in the refinement journal, if"
              "the engine supports it."
      .type = bool

    log = None
      .help = "Filename for an optional log that a minimisation engine may use"
              "to write additional information"
      .type = path
  }

  target
    .help = "Parameters to configure the target function"
  {
    implementation = *basic
      .help = "The target object type to use. Only basic exists at present"
      .type = choice

    rmsd_cutoff = *fraction_of_bin_size absolute
      .help = "Method to choose rmsd cutoffs. This is currently either as a"
              "fraction of the discrete units of the spot positional data, i.e."
              "(pixel width, pixel height, image thickness in phi), or a tuple"
              "of absolute values to use as the cutoffs"
      .type = choice

    bin_size_fraction = 0.33333
      .help = "Cut off in the natural discrete units of positional data, viz.,"
              "(pixel width, pixel height, image thickness in phi) to use to"
              "determine when the RMSD target is achieved. Only used if"
              "rmsd_cutoff = fraction_of_bin_size."
      .type = float(value_min=0.)

    absolute_cutoffs = None
      .help = "Absolute Values for the RMSD target achieved cutoffs in X, Y and"
              "Phi. The units are (mm, mm, rad)."
      .type = floats(size=3, value_min=0.)
  }

  reflections
    .help = "Parameters used by the reflection manager"
  {
    reflections_per_degree = 50
      .help = "The number of centroids per degree of the sweep to use in"
              "refinement."
      .type = float(value_min=0.)

    use_all_reflections = False
      .help = "Override reflections_per_degree and use all available centroids"
              "in refinement."
      .type = bool

    minimum_number_of_reflections = 20
      .help = "The minimum number of input observations to allow a reflection"
              "manager to be constructed for."
      .type = int(value_min=1)
  }
}
