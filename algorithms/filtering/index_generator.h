#ifndef CCTBX_MILLER_INDEX_GENERATOR_H
#define CCTBX_MILLER_INDEX_GENERATOR_H

#include <cctbx/sgtbx/reciprocal_space_asu.h>
#include <scitbx/array_family/loops.h>
#include <scitbx/array_family/tiny_algebra.h>

// FIXME THIS FILE WAS COPIED FROM CCTBX/MILLER/INDEX_GENERATOR
// WHERE IT IS SPLIT INTO .H/.CPP FILES MAKING IT DIFFICULT TO USE
// IN OTHER CPP FILES. COPYING THE FILE ISN'T IDEAL AND A PROPER FIX
// SHOULD PROBABLY BE DONE


namespace cctbx { namespace miller {

  /*! \brief Efficient, easy-to-use algorithm for building
      an asymmetric unit of Miller indices up to a given
      high-resolution limit or up to a given maximum Miller
      index.
   */
  /*! Example (Python syntax):<pre>
        # Given a resolution limit.
        unit_cell = uctbx.unit_cell((10, 10, 10, 90, 90, 90))
        sg_type = sgtbx.space_group_type("P 41")
        mig = sgtbx.miller_index_generator(unit_cell, sg_type, 1, 3.0)
        for h in mig: print h
        #
        # Given a maximum Miller index.
        sg_type = sgtbx.space_group_type("P 31")
        mig = sgtbx.miller_index_generator(sg_type, 1, (3,4,5))
        for h in mig: print h
      </pre>
      This class is implemented as an iterator. Therefore
      the generation of Miller indices does not consume any
      significant amounts of memory. The key to efficiency
      is cctbx::sgtbx::reciprocal_space::reference_asu .
   */
  class index_generator
  {
    public:
      //! Default constructor.
      /*! Default-constructed instances will throw exceptions if
          some of the member functions are used.
       */
      index_generator() {}

      //! Initialization with resolution limit.
      /*! Miller indices up to and including resolution_d_min will
          be generated.
       */
      index_generator(uctbx::unit_cell const& unit_cell,
                                       sgtbx::space_group_type const& sg_type,
                                       bool anomalous_flag,
                                       double resolution_d_min)
        : unit_cell_(unit_cell),
          sg_type_(sg_type),
          anomalous_flag_(anomalous_flag),
          asu_(sg_type)
      {
        if (resolution_d_min <= 0.) {
          throw error("Resolution limit must be greater than zero.");
        }
        d_star_sq_max_ = 1. / (resolution_d_min * resolution_d_min);
        uctbx::unit_cell
          reference_unit_cell = unit_cell_.change_basis(sg_type_.cb_op());
        initialize_loop(reference_unit_cell.max_miller_indices(resolution_d_min));
      }

      //! Initialization with maximum Miller index.
      /*! Miller indices in the range from -max_index to +max_index
          will be generated.
       */
      index_generator(sgtbx::space_group_type const& sg_type,
                                       bool anomalous_flag,
                                       index<> const& max_index)
        : sg_type_(sg_type),
          anomalous_flag_(anomalous_flag),
          asu_(sg_type),
          d_star_sq_max_(-1.)
      {
        initialize_loop(index<>(af::absolute(max_index.as_tiny())));
      }

      //! Unit cell in use.
      uctbx::unit_cell const&
      unit_cell() const { return unit_cell_; }

      //! Space group in use.
      sgtbx::space_group_type const&
      space_group_type() const { return sg_type_; }

      //! Anomalous flag in use.
      bool
      anomalous_flag() const { return anomalous_flag_; }

      //! Access to the reciprocal space asymmetric unit.
      /*! The Miller indices that are generated by this class (member
          function next()) are inside this asymmetric unit.
       */
      sgtbx::reciprocal_space::asu const&
      asu() const { return asu_; }

      //! Iterator over Miller indices.
      /*! Each call to this member function will return the next
          Miller index in the sequence. The indices are inside
          sgtbx::reciprocal_space::asu(). Systematically absent
          reflections are automatically filtered out.
          <p>
          The Miller index (0,0,0) indicates the end of the iteration.
       */
      index<>
      next()
      {
        if (!anomalous_flag_) return next_under_friedel_symmetry();
        if (next_is_minus_previous_) {
          next_is_minus_previous_ = false;
          return -previous_;
        }
        previous_ = next_under_friedel_symmetry();
        if (previous_.is_zero()) return previous_;
        next_is_minus_previous_ = !phase_info_.is_centric();
        return previous_;
      }

      //! Returns all Miller indices in an array.
      /*! The next() method is called in a loop until the list
          of Miller indices is exhausted.
       */
      af::shared<index<> >
      to_array()
      {
        af::shared<index<> > result;
        for (;;) {
          index<> h = next();
          if (h.is_zero()) break;
          result.push_back(h);
        }
        return result;
      }

    private:
      uctbx::unit_cell unit_cell_;
      sgtbx::space_group_type sg_type_;
      bool anomalous_flag_;

      sgtbx::reciprocal_space::asu asu_;
      double d_star_sq_max_;
      af::nested_loop<index<> > loop_;
      bool next_is_minus_previous_;
      sgtbx::phase_info phase_info_;
      index<> previous_;

      void
      initialize_loop(index<> const& reference_h_max)
      {
        af::int3 cut = asu_.reference()->cut_parameters();
        index<> reference_h_begin;
        index<> reference_h_end;
        for(std::size_t i=0;i<3;i++) {
          reference_h_begin[i] = reference_h_max[i] * cut[i];
          reference_h_end[i] = reference_h_max[i] + 1;
        }
        loop_ = af::nested_loop<index<> >(reference_h_begin, reference_h_end);
        next_is_minus_previous_ = false;
      }

      bool
      set_phase_info(index<> const& h)
      {
        phase_info_ = sgtbx::phase_info(sg_type_.group(), h, false);
        return phase_info_.is_sys_absent();
      }

      index<>
      next_under_friedel_symmetry()
      {
        int r_den = asu_.cb_op().c().r().den();
        for (; loop_.over() == 0;) {
          index<> reference_h = loop_();
          loop_.incr();
          if (asu_.reference()->is_inside(reference_h)) {
            if (asu_.is_reference()) {
              if (d_star_sq_max_ < 0.) {
                if (!reference_h.is_zero() && !set_phase_info(reference_h)) {
                  return reference_h;
                }
              }
              else {
                double d_star_sq = unit_cell_.d_star_sq(reference_h);
                if (d_star_sq != 0 && d_star_sq <= d_star_sq_max_
                    && !set_phase_info(reference_h)) {
                  return reference_h;
                }
              }
            }
            else {
              sgtbx::tr_vec hr(reference_h * asu_.cb_op().c().r(), r_den);
              hr = hr.cancel();
              if (hr.den() == 1) {
                index<> h(hr.num());
                if (d_star_sq_max_ < 0.) {
                  if (!h.is_zero() && !set_phase_info(h)) {
                    return h;
                  }
                }
                else {
                  double d_star_sq = unit_cell_.d_star_sq(h);
                  if (d_star_sq != 0 && d_star_sq <= d_star_sq_max_
                      && !set_phase_info(h)) {
                    return h;
                  }
                }
              }
            }
          }
        }
        return index<>(0,0,0);
      }
  };

}} // namespace cctbx::miller

#endif // CCTBX_MILLER_INDEX_GENERATOR_H
