from __future__ import division

try:
  # try importing scipy.linalg before any cctbx modules, otherwise we
  # sometimes get a segmentation fault/core dump if it is imported after
  # scipy.linalg is a dependency of sklearn.cluster.DBSCAN
  import scipy.linalg # import dependency
except ImportError, e:
  pass

from libtbx.phil import command_line
import iotbx.phil
from dials.util.options import OptionParser
from dials.util.options import flatten_reflections
from dials.util.options import flatten_datablocks
from dials.util.options import flatten_experiments

help_message = '''

This program attempts to perform autoindexing on strong spots output by the
program dials.find_spots. The program is called with a "datablock.json" file
(as generated by dials.import) and a "strong.pickle" file (as generated by
dials.find_spots). If one or more lattices are identified given the input
list of strong spots, then the crystal orientation and experimental geometry
are refined to minimise the differences between the observed and predicted
spot centroids. The program will output an "experiments.json" file which
is similar to the input "datablock.json" file, but with the addition of the
crystal model(s), and an "indexed.pickle" file which is similar to the input
"strong.pickle" file, but with the addition of miller indices and predicted
spot centroids.

dials.index provides both one-dimensional and three-dimensional fast Fourier
transform (FFT) based methods. These can be chosen by setting the parameters
indexing.method=fft1d or indexing.method=fft3d. By default the program searches
for a primitive lattice, and then proceeds with refinement in space group P1.
If the unit_cell and space_group parameters are set, then the program will
only accept solutions which are consistent with these parameters. Space group
constraints will be enforced in refinement as appropriate.

Examples::

  dials.index datablock.json strong.pickle

  dials.index datablock.json strong.pickle unit_cell=37,79,79,90,90,90 space_group=P43212

  dials.index datablock.json strong.pickle indexing.method=fft1d

'''

phil_scope = iotbx.phil.parse("""\
include scope dials.algorithms.indexing.indexer.master_phil_scope
output {
  experiments = experiments.json
    .type = path
  reflections = indexed.pickle
    .type = path
}
""", process_includes=True)


def run(args):
  import libtbx.load_env
  from libtbx.utils import Sorry
  usage = "%s [options] datablock.json strong.pickle" %libtbx.env.dispatcher_name

  parser = OptionParser(
    usage=usage,
    phil=phil_scope,
    read_reflections=True,
    read_datablocks=True,
    read_experiments=True,
    check_format=False,
    epilog=help_message)

  params, options = parser.parse_args(show_diff_phil=True)
  datablocks = flatten_datablocks(params.input.datablock)
  experiments = flatten_experiments(params.input.experiments)
  reflections = flatten_reflections(params.input.reflections)

  if len(datablocks) == 0:
    if len(experiments) > 0:
      imagesets = importer.experiments.imagesets()
    else:
      parser.print_help()
      return
  elif len(datablocks) > 1:
    raise Sorry("Only one DataBlock can be processed at a time")
  else:
    imagesets = datablocks[0].extract_imagesets()
  if len(experiments):
    known_crystal_models = experiments.crystals()
  else:
    known_crystal_models = None
  assert(len(reflections) == 1)
  reflections = reflections[0]

  for imageset in imagesets:
    if (imageset.get_goniometer() is not None and
        imageset.get_scan() is not None and
        imageset.get_scan().get_oscillation()[1] == 0):
      imageset.set_goniometer(None)
      imageset.set_scan(None)

  if known_crystal_models is not None:
    from dials.algorithms.indexing.known_orientation \
         import indexer_known_orientation
    idxr = indexer_known_orientation(
      reflections, imagesets, params, known_crystal_models)
  elif params.indexing.method == "fft3d":
    from dials.algorithms.indexing.fft3d import indexer_fft3d
    idxr = indexer_fft3d(reflections, imagesets, params=params)
  elif params.indexing.method == "fft1d":
    from dials.algorithms.indexing.fft1d import indexer_fft1d
    idxr = indexer_fft1d(reflections, imagesets, params=params)
  elif params.indexing.method == "real_space_grid_search":
    from dials.algorithms.indexing.real_space_grid_search \
         import indexer_real_space_grid_search
    idxr = indexer_real_space_grid_search(reflections, imagesets, params=params)
  refined_experiments = idxr.refined_experiments
  refined_reflections = idxr.refined_reflections
  if len(refined_experiments):
    idxr.export_as_json(refined_experiments,
                        file_name=params.output.experiments)
    idxr.export_reflections(
      refined_reflections, file_name=params.output.reflections)

  return


if __name__ == '__main__':
  import sys
  run(sys.argv[1:])
